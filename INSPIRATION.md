Inspiration
==========

I want to start off by mentioning that I have great respect for all the projects mentioned below and their extremely brilliant contributers!

Pouch/CouchDB - are currently the closest thing to an open source success that allows clients to the same database offline and online, but if you dive deeper you'll find that CouchDB is missing too many features, e.g. db-per-user, fast initial sync, etc... to really be used as the backend for a frontend only architecture. In other words, you still need a server-side routine in the middle of your app and CouchDB. The Couch team doesn't appear to be focusing on improving this area of Couch. Hoodie looks promising, but has just now started to migrate from a local storage solution to PouchDB and in the end it, it probably won't be able to sidestep CouchDB's challenges with speed, a chatty change feed, missing permission support, etc..

PouchDB/CouchDB - one of the most obvious issues is with the way updates are transmitted, e.g. let's say we have a list of 100 projects and each project has been updated 100 times. The client would need to download all 10,000 (=100x100)records just to get the latest values for all 100 projects. One of the fastest methods for downloading batches of CouchDB docs is using pouchdb-dump-cli, which takes 60 seconds to download 1,000 docs!! Could you imagine your app taking 60 seconds upon the inital load for just 1,000 docs?? DeltaDB solves this by allowing the client to only download the latest changes, i.e. only 100 records. Moreover, DeltaDB is just plain fast--it takes less than a second to download 10,000 deltas and that even includes filtering based on user roles!!

PouchDB/CouchDB use a document revision number conflict resolution policy that can be quite limiting. Under this policy, when two clients are offline and edit the same doc, the first client to sync wins and the second client's change just fails. This is true even if the second client made the change after the first client. This can be particularly problematic if you have pieces of a document that are modified by two clients at the same time, e.g. a task list where one client is updating the task and the other client is sorting the tasks. You can switch to a last-write-wins conflict resolution policy using the delta-pouch plugin, but this makes syncing even slower as it implements an every-doc-is-a-delta structure which quickly leads to a very high number of docs.

Firebase - pretty great, but proprietary and isn't offline compatible and since 2013 the Firebase team has been promising that they will make it offline compatible, but they haven't.

Meteor - fast, but not offline compatible and in 2014 I asked the lead developer during Meteor Day if they plan to support offline and they said "No, this is the dev's task." Offline support is tough and shouldn't be solely the dev's responsibility. Also, Meteor claims to support other technologies like AngularJS, etc... but it appears to me that you have to do some nasty hacking to get them to work--also the real power of Meteor appears to be in using everything it offers.

Adding offline support to meteor and firebase is much more complicated than just hyjacking the startup and termination of an app, e.g. on startup move persistent locally stored data to meteor/fb and then upon termination copy from meteor/fb to persistent storage. If there is no Internet connection during the startup and termination, complicated logic is needed to figure out how data is buffered and then synced when a connection becomes available. To do this properly, this type of logic needs to be built into the DB layer.
